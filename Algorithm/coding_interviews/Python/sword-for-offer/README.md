# sword-for-offer

使用Python3用pythonic的方式实现《剑指Offer 第二版》中的题目。拒绝直接“翻译”java等实现。代码有些并非原创，搬运了一些LeetCode中大神的优秀解法，比如：如何用一行代码实现`顺时针打印矩阵`。
基本所有题都包含对应网站链接。建议优先选择LeetCode答题，相对来说testcase比较全面。源码包含doctest，如想了解更多LeetCode题解，请移步[我的博客](https://darktiantian.github.io/%E5%89%91%E6%8C%87Offer/)。

### 第2章 面试需要的基础知识

### 2.3 [数据结构](/chapter_2/section_3)
> #### [3 数组中重复的数字](/chapter_2/section_3#3-数组中重复的数字)
> #### [4 二维数组中的查找](/chapter_2/section_3#4-二维数组中的查找)
> #### [5 替换空格](/chapter_2/section_3#5-替换空格)
> #### [6 从尾到头打印链表](/chapter_2/section_3#6-从尾到头打印链表)
> #### [7 重建二叉树](/chapter_2/section_3#7-重建二叉树)
> #### [9 用两个栈实现队列](/chapter_2/section_3#9-用两个栈实现队列)
> #### [9.1 用两个队列实现栈](/chapter_2/section_3#9_1-用两个队列实现栈)

### 2.4 [算法和数据操作](/chapter_2/section_4)
> #### [10 斐波那契数列](/chapter_2/section_4#10-斐波那契数列)
> #### [11 旋转数组的最小数字](/chapter_2/section_4#11-旋转数组的最小数字)
> #### [12 矩阵中的路径](/chapter_2/section_4#12-矩阵中的路径)
> #### [13 机器人的运动范围](/chapter_2/section_4#13-机器人的运动范围)
> #### [14 剪绳子](/chapter_2/section_4#14-剪绳子)
> #### [15 二进制中1的个数](/chapter_2/section_4#15-二进制中1的个数)

### 第3章 高质量的代码

### 3.3 [代码的完整性](/chapter_3/section_3)
> #### [16 数值的整数次方](/chapter_3/section_3#16-数值的整数次方)
> #### [17 打印从1到最大的n位数](/chapter_3/section_3#17-打印从1到最大的n位数)
> #### [18 删除链表中的节点](/chapter_3/section_3#18-删除链表中的节点)
> #### [19 正则表达式](/chapter_3/section_3#19-正则表达式)
> #### [20 表示数值的字符串](/chapter_3/section_3#20-表示数值的字符串)
> #### [21 调整数组顺序使奇数位于偶数前面](/chapter_3/section_3#21-调整数组顺序使奇数位于偶数前面)

### 3.4 [代码的鲁棒性](/chapter_3/section_4)
> #### [22 链表中倒数第k个节点](/chapter_3/section_4#22-链表中倒数第k个节点)
> #### [23 链表中环的入口节点](/chapter_3/section_4#23-链表中环的入口节点)
> #### [24 反转链表](/chapter_3/section_4#24-反转链表)
> #### [25 合并两个有序链表](/chapter_3/section_4#25-合并两个有序链表)
> #### [26 树的子结构](/chapter_3/section_4#26-树的子结构)

### 第4章 解决面试题的思路

### 4.2 [画图让抽象问题形象化](/chapter_4/section_2)
> #### [27 二叉树的镜像](/chapter_4/section_2#27-二叉树的镜像)
> #### [28 对称的二叉树](/chapter_4/section_2#28-对称的二叉树)
> #### [29 顺时针打印矩阵](/chapter_4/section_2#29-顺时针打印矩阵)

### 4.3 [举例让抽象问题具体化](/chapter_4/section_3)
> #### [30 包含min函数的栈](/chapter_4/section_3#30-包含min函数的栈)
> #### [31 栈的压入、弹出序列](/chapter_4/section_3#31-栈的压入、弹出序列)
> #### [32 从上到下打印二叉树](/chapter_4/section_3#32-从上到下打印二叉树)
> #### [32.1 分层从上到下打印二叉树](/chapter_4/section_3#32_1-分层从上到下打印二叉树)
> #### [32.2 之字形打印二叉树](/chapter_4/section_3#32_2-之字形打印二叉树)
> #### [33 是否是二叉搜索树的后序遍历](/chapter_4/section_3#33-是否是二叉搜索树的后序遍历)
> #### [34 二叉树和为某一值的路径](/chapter_4/section_3#34-二叉树和为某一值的路径)

### 4.4 [分解让复杂问题简单化](/chapter_4/section_4)
> #### [35 复杂链表的复制](/chapter_4/section_4#35-复杂链表的复制)
> #### [36 二叉搜索树与双向链表](/chapter_4/section_4#36-二叉搜索树与双向链表)
> #### [37 序列化二叉树](/chapter_4/section_4#37-序列化二叉树)
> #### [38 字符串的排列](/chapter_4/section_4#38-字符串的排列)

### 第5章 优化时间和空间效率

### 5.2 [时间效率](/chapter_5/section_2)
> #### [39 数组中出现次数超过一半的数字](/chapter_5/section_2#39-数组中出现次数超过一半的数字)
> #### [40 最小的k个数](/chapter_5/section_2#40-最小的k个数)
> #### [41 数据流中的中位数](/chapter_5/section_2#41-数据流中的中位数)
> #### [42 连续子数组的最大和](/chapter_5/section_2#42-连续子数组的最大和)
> #### [43 1~n整数中1出现的次数](/chapter_5/section_2#43-1~n整数中1出现的次数)
> #### [44 数字序列中某一位的数字](/chapter_5/section_2#44-数字序列中某一位的数字)
> #### [45 把数组排成最小的数字](/chapter_5/section_2#45-把数组排成最小的数字)
> #### [46 把数字翻译成字符串](/chapter_5/section_2#46-把数字翻译成字符串)
> #### [47 礼物的最大价值](/chapter_5/section_2#47-礼物的最大价值)
> #### [48 最长不含重复字符的子字符串](/chapter_5/section_2#48-最长不含重复字符的子字符串)

### 5.3 [时间效率与空间效率的平衡](/chapter_5/section_3)
> #### [49 丑数](/chapter_5/section_3#49-丑数)
> #### [50 第一个只出现一次的字符](/chapter_5/section_3#50-第一个只出现一次的字符)
> #### [51 数组中的逆序对](/chapter_5/section_3#51-数组中的逆序对)
> #### [52 两个链表的第一个公共节点](/chapter_5/section_3#52-两个链表的第一个公共节点)

### 第6章 面试中的各项能力

### 6.2 [知识迁移能力](/chapter_6/section_3)
> #### [53 在排序数组中查找数字](/chapter_6/section_3#53-在排序数组中查找数字)
> #### [53 0~n-1中缺失的数字](/chapter_6/section_3#53-0~n-1中缺失的数字)
> #### [53 数组中数值和下标相等的元素](/chapter_6/section_3#53-数组中数值和下标相等的元素)
> #### [54 二叉搜索树的第k大节点](/chapter_6/section_3#54-二叉搜索树的第k大节点)
> #### [55 二叉树的深度](/chapter_6/section_3#55-二叉树的深度)
> #### [55_1 平衡二叉树](/chapter_6/section_3#55_1-平衡二叉树)
> #### [56 数组中只出现一次的两个数字。](/chapter_6/section_3#56-数组中只出现一次的两个数字。)
> #### [56_1 数组中出现一次的数字，其余元素出现三次。](/chapter_6/section_3#56_1-数组中出现一次的数字，其余元素出现三次。)
> #### [57 和为s的数字](/chapter_6/section_3#57-和为s的数字)
> #### [57_1 和为s的连续正数序列](/chapter_6/section_3#57_1-和为s的连续正数序列)
> #### [58 翻转字符串](/chapter_6/section_3#58-翻转字符串)
> #### [58_1 左旋转字符串](/chapter_6/section_3#58_1-左旋转字符串)
> #### [59 滑动窗口的最大值](/chapter_6/section_3#59-滑动窗口的最大值)

### 6.3 [抽象建模能力](/chapter_6/section_4)
> #### [60 n个骰子的点数](/chapter_6/section_4#60-n个骰子的点数)
> #### [61 扑克牌中的顺子](/chapter_6/section_4#61-扑克牌中的顺子)
> #### [62 圆圈中最后剩下的数字](/chapter_6/section_4#62-圆圈中最后剩下的数字)
> #### [63 股票的最大利润](/chapter_6/section_4#63-股票的最大利润)

### 6.4 [发散思维能力](/chapter_6/section_5)
> #### [64 求1+2+···+n](/chapter_6/section_5#64-求1+2+···+n)
> #### [65 不用加减乘除做加法](/chapter_6/section_5#65-不用加减乘除做加法)
> #### [66 构建乘积数组](/chapter_6/section_5#66-构建乘积数组)
